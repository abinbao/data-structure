# data-structure
数据结构与算法

#### 01 为什么要学习数据结构与算法

- 数据结构和算法
- 操作系统
- 计算机网络



**时间复杂度**

**空间复杂度**

#### 02 如何高效学习数据结构与算法



**广义**

数据结构就是指一组数据的存储格式。

算法就是操作数据的一组方法。

**狭义**

指著名 的数据结构和算法，比如 队列、栈、堆、二分查找、动态规划等



**数据结构是为算法服务的，算法要作用在特定的数据机构中**



##### 学习重点

- 复杂度分析

![913e0ababe43a2d57267df5c5f0832a7](./913e0ababe43a2d57267df5c5f0832a7.jpg)



**常用基础数据结构和算法**

- 数据结构
  - 数组
  - 链表
  - 栈
  - 队列
  - 散列表
  - 二叉树
  - 堆
  - 跳表
  - 图
  - Trie 数
- 算法
  - 递归
  - 排序
  - 二分查找
  - 搜索
  - 哈希算法
  - 贪心算法
  - 分治算法
  - 回溯算法
  - 动态规划
  - 字符串匹配



#### 03 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗

**快** **省**

- 时间复杂度
- 空间复杂度



##### 为什么要复杂度分析？

1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大

##### 大 O 复杂度表示法

```java
public int cal(int n) {
    int sum = 0;
    int i = 1;
    for(;int i <= n; ++i) {
        sum = sum + i;
    }
    return sum;
}
```

**读数据-运算-写数据**

假设每行代码执行时间一样，为 **unit_time**

2、3 行代码分别要 1 个 **unit_time** 的执行时间

4、5 行代码运行了 n 遍

共 （2n+2）unit_time 的时间

代码的执行时间 **T(n)** 和每行代码的执行次数成正比



```java
 public int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }

```

T(n) = (2n2+2n+3)*unit_time  

![22900968aa2b190072c985a08b0e92ef](./22900968aa2b190072c985a08b0e92ef.png)



我来具体解释一下这个公式。其中，T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与  f(n) 表达式成正比。

**大O时间复杂度表示法**

并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫**渐进时间复杂度**

T(n) = O(n)； T(n) = O(n2)。



##### 时间复杂度分析

- 只关注循环执行次数最多的一段代码

```c++
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }

```



- 加法法则：总复杂度等于量级最大的那段代码的复杂度

```c++
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }

```

- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

```c
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }

```



##### 几种常见复杂度示例分析

![3723793cc5c810e9d5b06bc95325bf0a](./3723793cc5c810e9d5b06bc95325bf0a.jpg)

- 多项式量级
- 非多项式量级 **O(2n) 和 O(n!)**

##### 空间复杂度分析

表示算法的存储空间和数据规模之间的增长关系

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```



![497a3f120b7debee07dc0d03984faf04](./497a3f120b7debee07dc0d03984faf04.jpg)



####  04 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度

- 最好情况时间复杂度
- 最坏情况时间复杂度
- 平均情况时间复杂度
- 均摊时间复杂度

##### 最好、最坏情况时间复杂度

```java
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
```



### 05 数组：为什么很多编程语言中数组都从 0 开始编号？



##### 如何实现随机访问？

**数组是一种线性表数据结构。用一组连续的内存空间，来存储一组具有相同类型的数据。**

- 线性表

  - 数组
  - 链表
  - 队列
  - 栈

  ![b6b71ec46935130dff5c4b62cf273477](./b6b71ec46935130dff5c4b62cf273477.jpg)

- 非线性表

  - 二叉树
  - 堆
  - 图

  ![6ebf42641b5f98f912d36f6bf86f6569](./6ebf42641b5f98f912d36f6bf86f6569.jpg)

- 连续的内存空间和相同类型的数据

![98df8e702b14096e7ee4a5141260cdc4](./98df8e702b14096e7ee4a5141260cdc4.jpg)

##### 低效的**"插入"**和**"删除"**

- 插入操作
- 删除操作



**警惕数组的访问越界问题**



##### 容器能否完全代替数组？

**ArrayList 优势**

-  将很多数组操作的细节封装起来
- 支持动态扩容
- 自动扩容 1.5 倍

```java
ArrayList<User> users = new ArrayList(10000);
for (int i = 0; i < 10000; ++i) {
  users.add(xxx);
}
```



用数组更适合的情况：

- Java ArrayList 无法存储基础数据类型，例如 int、long，需要封装成 Integer、Long 类，而 Autoboxing、unboxing 则有一定的性能消耗，所以如果特备关注性能，或者系统使用基本类型，就可以选用数组
- 如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList 提供的大部分方法，也可以直接使用数组
- 多维数组



### 06 链表（上）：如何实现 LRU 缓存淘汰算法？

链表应用场景：LRU缓存淘汰算法



#### 缓存

- CPU 缓存
- 数据库缓存
- 浏览器缓存

#### 缓存淘汰策略

- 先进先出策略 FIFO
- 最少使用策略 LFU
- 最近最少使用策略 LRU

#### 五花八门的链表结构

![d5d5bee4be28326ba3c28373808a62cd](./d5d5bee4be28326ba3c28373808a62cd.jpg)

- 单链表
- 双向链表
- 循环链表

##### 单链表

![b93e7ade9bb927baad1348d9a806ddeb](./b93e7ade9bb927baad1348d9a806ddeb.jpg)

- 头结点
  - 记录链表的基地址
- 尾结点
  - 指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点

查找、插入、删除

![452e943788bdeea462d364389bd08a17](./452e943788bdeea462d364389bd08a17.jpg)

随机查找：

时间复杂度 O(n)

##### 循环链表

![86cb7dc331ea958b0a108b911f38d155](./86cb7dc331ea958b0a108b911f38d155.jpg)

##### 双向链表

![cbc8ab20276e2f9312030c313a9ef70b](./cbc8ab20276e2f9312030c313a9ef70b.jpg)

##### 链表 VS 数组性能比较

![4f63e92598ec2551069a0eef69db7168](./4f63e92598ec2551069a0eef69db7168.jpg)



### 07 链表（下）：如何轻松写出正确的链表代码



- **技巧一**：理解指针或引用的含义

  将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

- **技巧二**：警惕指针丢失和内存泄漏

- **技巧三**：利用哨兵简化实现难度

- **技巧四**：重点留意边界条件处理

  - 如果链表为空时，代码是否能正常工作？
  - 如果链表只包含一个结点时，代码是否能正常工作？
  - 如果链表只包含两个结点时，代码是否能正常工作？
  - 代码逻辑在处理头结点和尾结点时，是否能正常工作？

**5 个常见的链表操作**

- 单链表反转

  ```java
  /*
  public class ListNode {
      int val;
      ListNode next = null;
  
      ListNode(int val) {
          this.val = val;
      }
  }*/
  public class Solution {
      public ListNode ReverseList(ListNode head) {
         
          if(head==null)
              return null;
          //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；
          ListNode pre = null;
          ListNode next = null;
          //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点
          //需要pre和next的目的是让当前节点从pre->head->next1->next2变成pre<-head next1->next2
          //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了
          //所以需要用到pre和next两个节点
          //1->2->3->4->5
          //1<-2<-3 4->5
          while(head!=null){
              //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre
              //如此就可以做到反转链表的效果
              //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂
              next = head.next;
              //保存完next，就可以让head从指向next变成指向pre了，代码如下
              head.next = pre;
              //head指向pre后，就继续依次反转下一个节点
              //让pre，head，next依次向后移动一个节点，继续下一次的指针反转
              pre = head;
              head = next;
          }
          //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点
          //直接输出pre就是我们想要得到的反转后的链表
          return pre;
      }
  }
  ```

- 链表中环的检测

- 两个有序的链表合并

- 删除链表倒数第 n 个结点

- 求链表的中间结点



